<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sweetapps/nosmoketimer/feature/run/RunActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sweetapps/nosmoketimer/feature/run/RunActivity.kt" />
              <option name="originalContent" value="package com.sweetapps.nosmoketimer.feature.run&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.widget.Toast&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.background&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.colorResource&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.PlatformTextStyle&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.core.content.edit&#10;import java.util.Locale&#10;import com.sweetapps.nosmoketimer.core.ui.BaseActivity&#10;import com.sweetapps.nosmoketimer.core.ui.StandardScreenWithBottomButton&#10;import com.sweetapps.nosmoketimer.core.util.Constants&#10;import com.sweetapps.nosmoketimer.feature.level.LevelDefinitions&#10;import com.sweetapps.nosmoketimer.core.util.FormatUtils&#10;import kotlinx.coroutines.delay&#10;import com.sweetapps.nosmoketimer.feature.start.StartActivity&#10;import com.sweetapps.nosmoketimer.feature.detail.DetailActivity&#10;import com.sweetapps.nosmoketimer.core.ui.AppElevation&#10;import androidx.compose.foundation.BorderStroke&#10;import com.sweetapps.nosmoketimer.R&#10;&#10;class RunActivity : BaseActivity() {&#10;&#10;    override fun getScreenTitle(): String = getString(R.string.run_title)&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            BaseScreen(applyBottomInsets = false) {&#10;                RunScreen()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RunScreen() {&#10;    val context = LocalContext.current&#10;&#10;    val sp = remember { context.getSharedPreferences(Constants.USER_SETTINGS_PREFS, Context.MODE_PRIVATE) }&#10;    val startTime = remember { sp.getLong(Constants.PREF_START_TIME, 0L) }&#10;    val targetDays = remember { sp.getFloat(Constants.PREF_TARGET_DAYS, 30f) }&#10;    val timerCompleted = remember { sp.getBoolean(Constants.PREF_TIMER_COMPLETED, false) }&#10;&#10;    LaunchedEffect(startTime, timerCompleted) {&#10;        if (timerCompleted || startTime == 0L) {&#10;            context.startActivity(Intent(context, StartActivity::class.java).apply {&#10;                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)&#10;            })&#10;            (context as? RunActivity)?.finish()&#10;        }&#10;    }&#10;&#10;    var now by remember { mutableLongStateOf(System.currentTimeMillis()) }&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            delay(1000)&#10;            now = System.currentTimeMillis()&#10;        }&#10;    }&#10;&#10;    val elapsedMillis by remember(now, startTime) {&#10;        derivedStateOf { if (startTime &gt; 0) now - startTime else 0L }&#10;    }&#10;    val elapsedDaysFloat = remember(elapsedMillis) { elapsedMillis / Constants.DAY_IN_MILLIS.toFloat() }&#10;    val elapsedDays = remember(elapsedDaysFloat) { elapsedDaysFloat.toInt() }&#10;&#10;    val levelDays = remember(elapsedMillis) { Constants.calculateLevelDays(elapsedMillis) }&#10;    val levelInfo = remember(levelDays) { LevelDefinitions.getLevelInfo(levelDays) }&#10;    val levelName = levelInfo.name&#10;&#10;    val elapsedHours = ((elapsedMillis % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000)).toInt()&#10;    val elapsedMinutes = ((elapsedMillis % (60 * 60 * 1000)) / (60 * 1000)).toInt()&#10;    val elapsedSeconds = ((elapsedMillis % (60 * 1000)) / 1000).toInt()&#10;    val progressTimeText = String.format(Locale.getDefault(), &quot;%02d:%02d:%02d&quot;, elapsedHours, elapsedMinutes, elapsedSeconds)&#10;    val progressTimeTextHM = String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, elapsedHours, elapsedMinutes)&#10;&#10;    val (selectedCost, selectedFrequency, selectedDuration) = Constants.getUserSettings(context)&#10;    val costVal = when (selectedCost) { &quot;저&quot; -&gt; 10000; &quot;중&quot; -&gt; 40000; &quot;고&quot; -&gt; 70000; else -&gt; 40000 }&#10;    val freqVal = when (selectedFrequency) { &quot;주 1회 이하&quot; -&gt; 1.0; &quot;주 2~3회&quot; -&gt; 2.5; &quot;주 4회 이상&quot; -&gt; 5.0; else -&gt; 2.5 }&#10;    val drinkHoursVal = when (selectedDuration) { &quot;짧음&quot; -&gt; 2; &quot;보통&quot; -&gt; 4; &quot;김&quot; -&gt; 6; else -&gt; 4 }&#10;    val weeks = elapsedDaysFloat / 7.0&#10;    val savedMoney = remember(weeks, freqVal, costVal) { weeks * freqVal * costVal }&#10;    val savedHours = remember(weeks, freqVal, drinkHoursVal) { weeks * freqVal * (drinkHoursVal + Constants.DEFAULT_HANGOVER_HOURS) }&#10;    val lifeGainDays = remember(elapsedDaysFloat) { elapsedDaysFloat / 30.0 }&#10;&#10;    val totalTargetMillis = (targetDays * Constants.DAY_IN_MILLIS).toLong()&#10;    val progress = remember(elapsedMillis, totalTargetMillis) {&#10;        if (totalTargetMillis &gt; 0) (elapsedMillis.toFloat() / totalTargetMillis).coerceIn(0f, 1f) else 0f&#10;    }&#10;&#10;    val indicatorKey = remember(startTime) { Constants.keyCurrentIndicator(startTime) }&#10;    var currentIndicator by remember { mutableIntStateOf(sp.getInt(indicatorKey, 0)) }&#10;&#10;    fun toggleIndicator() { val next = (currentIndicator + 1) % 5; currentIndicator = next; sp.edit { putInt(indicatorKey, next) } }&#10;&#10;    var hasCompleted by remember { mutableStateOf(false) }&#10;    LaunchedEffect(progress) {&#10;        if (!hasCompleted &amp;&amp; progress &gt;= 1f &amp;&amp; startTime &gt; 0) {&#10;            try {&#10;                saveCompletedRecord(&#10;                    context = context,&#10;                    startTime = startTime,&#10;                    endTime = System.currentTimeMillis(),&#10;                    targetDays = targetDays,&#10;                    actualDays = (elapsedMillis / Constants.DAY_IN_MILLIS).toInt()&#10;                )&#10;                sp.edit { remove(Constants.PREF_START_TIME); putBoolean(Constants.PREF_TIMER_COMPLETED, true) }&#10;                hasCompleted = true&#10;                Toast.makeText(context, context.getString(R.string.toast_goal_completed), Toast.LENGTH_SHORT).show()&#10;                DetailActivity.start(&#10;                    context = context,&#10;                    startTime = startTime,&#10;                    endTime = System.currentTimeMillis(),&#10;                    targetDays = targetDays,&#10;                    actualDays = (elapsedMillis / Constants.DAY_IN_MILLIS).toInt(),&#10;                    isCompleted = true&#10;                )&#10;                (context as? RunActivity)?.finish()&#10;            } catch (_: Exception) { }&#10;        }&#10;    }&#10;&#10;    StandardScreenWithBottomButton(&#10;        topContent = {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = AppElevation.CARD),&#10;                border = BorderStroke(1.dp, colorResource(id = R.color.color_border_light))&#10;            ) {&#10;                Column(modifier = Modifier.fillMaxWidth().padding(20.dp)) {&#10;                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                        RunStatChip(title = stringResource(id = R.string.stat_goal_days), value = &quot;${targetDays.toInt()}일&quot;, color = colorResource(id = R.color.color_stat_goal), modifier = Modifier.weight(1f))&#10;                        RunStatChip(title = stringResource(id = R.string.stat_level), value = levelName.take(6), color = levelInfo.color, modifier = Modifier.weight(1f))&#10;                        RunStatChip(title = stringResource(id = R.string.stat_time), value = progressTimeTextHM, color = colorResource(id = R.color.color_stat_time), modifier = Modifier.weight(1f))&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth().height(168.dp).clickable { toggleIndicator() },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = AppElevation.CARD),&#10;                border = BorderStroke(1.dp, colorResource(id = R.color.color_border_light))&#10;            ) {&#10;                Box(modifier = Modifier.fillMaxSize().padding(16.dp), contentAlignment = Alignment.Center) {&#10;                    val labelBoxH = 36.dp; val valueBoxH = 66.dp; val hintBoxH = 20.dp; val gapSmall = 6.dp; val gapMedium = 8.dp&#10;                    val (label, valueText, valueColor) = when (currentIndicator) {&#10;                        0 -&gt; Triple(stringResource(id = R.string.indicator_title_days), String.format(Locale.getDefault(), &quot;%.1f&quot;, elapsedDaysFloat), colorResource(id = R.color.color_indicator_days))&#10;                        1 -&gt; Triple(stringResource(id = R.string.indicator_title_time), progressTimeText, colorResource(id = R.color.color_indicator_time))&#10;                        2 -&gt; Triple(stringResource(id = R.string.indicator_title_saved_money), String.format(Locale.getDefault(), &quot;%,.0f원&quot;, savedMoney).replace(&quot; &quot;, &quot;&quot;), colorResource(id = R.color.color_indicator_money))&#10;                        3 -&gt; Triple(stringResource(id = R.string.indicator_title_saved_hours), String.format(Locale.getDefault(), &quot;%.1f&quot;, savedHours), colorResource(id = R.color.color_indicator_hours))&#10;                        else -&gt; Triple(stringResource(id = R.string.indicator_title_life_gain), FormatUtils.daysToDayHourString(lifeGainDays, 2), colorResource(id = R.color.color_indicator_life))&#10;                    }&#10;                    Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                        Box(modifier = Modifier.fillMaxWidth().height(labelBoxH), contentAlignment = Alignment.Center) {&#10;                            val base = MaterialTheme.typography.titleMedium&#10;                            Text(&#10;                                text = label,&#10;                                style = base.copy(&#10;                                    color = colorResource(id = R.color.color_indicator_label_gray),&#10;                                    lineHeight = base.fontSize * 1.2f,&#10;                                    platformStyle = PlatformTextStyle(includeFontPadding = true)&#10;                                ),&#10;                                textAlign = TextAlign.Center,&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis&#10;                            )&#10;                        }&#10;                        Spacer(modifier = Modifier.height(gapSmall))&#10;                        Box(modifier = Modifier.fillMaxWidth().height(valueBoxH), contentAlignment = Alignment.Center) {&#10;                            val baseStyle = MaterialTheme.typography.headlineMedium&#10;                            val bigSize = (baseStyle.fontSize.value * 1.5f).sp&#10;                            val bigStyle = baseStyle.copy(&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = valueColor,&#10;                                fontSize = bigSize,&#10;                                lineHeight = bigSize * 1.1f,&#10;                                platformStyle = PlatformTextStyle(includeFontPadding = true),&#10;                                fontFeatureSettings = &quot;tnum&quot;&#10;                            )&#10;                            val unitStyle = baseStyle.copy(&#10;                                color = valueColor,&#10;                                fontWeight = FontWeight.SemiBold,&#10;                                fontSize = baseStyle.fontSize,&#10;                                lineHeight = baseStyle.fontSize * 1.1f,&#10;                                platformStyle = PlatformTextStyle(includeFontPadding = true)&#10;                            )&#10;                            val isMoney = currentIndicator == 2&#10;                            val isLifeGain = currentIndicator == 4&#10;                            if (isMoney) {&#10;                                val numeric = valueText.replace(&quot;원&quot;, &quot;&quot;)&#10;                                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#10;                                    Text(text = numeric, style = bigStyle, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip, modifier = Modifier.alignByBaseline())&#10;                                    Spacer(modifier = Modifier.width(2.dp))&#10;                                    Text(text = &quot;원&quot;, style = unitStyle, modifier = Modifier.alignByBaseline())&#10;                                }&#10;                            } else if (isLifeGain) {&#10;                                val twoPart = Regex(&quot;&quot;&quot;(\d+)\s*일\s*([0-9]+(?:\.[0-9]+)?)\s*시간&quot;&quot;&quot;)&#10;                                val onePart = Regex(&quot;&quot;&quot;([0-9]+(?:\.[0-9]+)?)\s*시간&quot;&quot;&quot;)&#10;                                val m1 = twoPart.find(valueText)&#10;                                val m2 = if (m1 == null) onePart.find(valueText) else null&#10;                                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#10;                                    if (m1 != null) {&#10;                                        val dStr = m1.groupValues[1]&#10;                                        val hStr = m1.groupValues[2]&#10;                                        Text(text = dStr, style = bigStyle, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip, modifier = Modifier.alignByBaseline())&#10;                                        Spacer(modifier = Modifier.width(2.dp))&#10;                                        Text(text = &quot;일&quot;, style = unitStyle, modifier = Modifier.alignByBaseline())&#10;                                        Spacer(modifier = Modifier.width(6.dp))&#10;                                        Text(text = hStr, style = bigStyle, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip, modifier = Modifier.alignByBaseline())&#10;                                        Spacer(modifier = Modifier.width(2.dp))&#10;                                        Text(text = &quot;시간&quot;, style = unitStyle, modifier = Modifier.alignByBaseline())&#10;                                    } else if (m2 != null) {&#10;                                        val hStr = m2.groupValues[1]&#10;                                        Text(text = hStr, style = bigStyle, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip, modifier = Modifier.alignByBaseline())&#10;                                        Spacer(modifier = Modifier.width(2.dp))&#10;                                        Text(text = &quot;시간&quot;, style = unitStyle, modifier = Modifier.alignByBaseline())&#10;                                    } else {&#10;                                        Text(text = valueText, style = bigStyle, textAlign = TextAlign.Center, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip)&#10;                                    }&#10;                                }&#10;                            } else {&#10;                                Text(&#10;                                    text = valueText,&#10;                                    style = bigStyle,&#10;                                    textAlign = TextAlign.Center,&#10;                                    maxLines = 1,&#10;                                    softWrap = false,&#10;                                    overflow = TextOverflow.Clip&#10;                                )&#10;                            }&#10;                        }&#10;                        Spacer(modifier = Modifier.height(gapMedium))&#10;                        Box(modifier = Modifier.fillMaxWidth().height(hintBoxH), contentAlignment = Alignment.Center) {&#10;                            val base = MaterialTheme.typography.labelMedium&#10;                            Text(&#10;                                text = stringResource(id = R.string.tap_to_switch_indicator),&#10;                                style = base.copy(&#10;                                    color = colorResource(id = R.color.color_hint_gray),&#10;                                    lineHeight = base.fontSize * 1.2f,&#10;                                    platformStyle = PlatformTextStyle(includeFontPadding = true)&#10;                                ),&#10;                                textAlign = TextAlign.Center,&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = AppElevation.CARD),&#10;                border = BorderStroke(1.dp, colorResource(id = R.color.color_border_light))&#10;            ) {&#10;                Column(modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) { ModernProgressIndicatorSimple(progress = progress) }&#10;            }&#10;        },&#10;        bottomButton = {&#10;            ModernStopButtonSimple(onStop = {&#10;                val intent = Intent(context, QuitActivity::class.java).apply {&#10;                    putExtra(&quot;elapsed_days&quot;, elapsedDays)&#10;                    putExtra(&quot;elapsed_hours&quot;, elapsedHours)&#10;                    putExtra(&quot;elapsed_minutes&quot;, elapsedMinutes)&#10;                    putExtra(&quot;saved_money&quot;, savedMoney)&#10;                    putExtra(&quot;saved_hours&quot;, savedHours)&#10;                    putExtra(&quot;life_gain_days&quot;, lifeGainDays)&#10;                    putExtra(&quot;level_name&quot;, levelName)&#10;                    putExtra(&quot;level_color&quot;, levelInfo.color.value.toLong())&#10;                    putExtra(&quot;quit_timestamp&quot;, System.currentTimeMillis())&#10;                }&#10;                context.startActivity(intent)&#10;            })&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun ModernProgressIndicatorSimple(progress: Float) {&#10;    var blink by remember { mutableStateOf(true) }&#10;    LaunchedEffect(Unit) { while (true) { delay(1000); blink = !blink } }&#10;    val alpha by animateFloatAsState(targetValue = if (blink) 1f else 0.3f, animationSpec = tween(durationMillis = 500, easing = androidx.compose.animation.core.FastOutSlowInEasing), label = &quot;blink&quot;)&#10;&#10;    Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;        Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.Center) {&#10;            Text(text = (progress * 100).toInt().coerceIn(0, 100).toString() + &quot;%&quot;, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold, color = colorResource(id = R.color.color_progress_primary)))&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Box(modifier = Modifier.size(6.dp).clip(CircleShape).background(colorResource(id = R.color.color_progress_primary).copy(alpha = alpha)))&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        LinearProgressIndicator(progress = { progress }, color = colorResource(id = R.color.color_progress_primary), trackColor = colorResource(id = R.color.color_progress_track), modifier = Modifier.fillMaxWidth().height(8.dp))&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun ModernStopButtonSimple(onStop: () -&gt; Unit, modifier: Modifier = Modifier) {&#10;    Card(&#10;        onClick = onStop,&#10;        modifier = modifier.size(96.dp),&#10;        shape = CircleShape,&#10;        colors = CardDefaults.cardColors(containerColor = colorResource(id = R.color.color_stop_button)),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = AppElevation.CARD_HIGH)&#10;    ) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            Icon(&#10;                imageVector = Icons.Default.Close,&#10;                contentDescription = stringResource(id = R.string.cd_stop),&#10;                tint = Color.White,&#10;                modifier = Modifier.size(48.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AutoResizeSingleLineText(&#10;    text: String,&#10;    baseStyle: TextStyle,&#10;    modifier: Modifier = Modifier,&#10;    minFontSizeSp: Float = 10f,&#10;    step: Float = 0.95f,&#10;    color: Color? = null,&#10;    textAlign: TextAlign? = null,&#10;) {&#10;    var style by remember(text) { mutableStateOf(baseStyle) }&#10;    var tried by remember(text) { mutableStateOf(0) }&#10;    Text(&#10;        text = text,&#10;        style = style,&#10;        color = color ?: style.color,&#10;        textAlign = textAlign,&#10;        maxLines = 1,&#10;        softWrap = false,&#10;        overflow = TextOverflow.Clip,&#10;        modifier = modifier,&#10;        onTextLayout = { result -&gt;&#10;            if (result.hasVisualOverflow &amp;&amp; tried &lt; 20) {&#10;                val current = style.fontSize.value&#10;                val next = (current * step).coerceAtLeast(minFontSizeSp)&#10;                if (next &lt; current - 0.1f) {&#10;                    style = style.copy(fontSize = next.sp, lineHeight = (next.sp * 1.1f))&#10;                    tried++&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun RunStatChip(title: String, value: String, color: Color, modifier: Modifier = Modifier) {&#10;    Surface(modifier = modifier.height(84.dp), shape = RoundedCornerShape(12.dp), color = color.copy(alpha = 0.1f)) {&#10;        Column(modifier = Modifier.fillMaxWidth().padding(12.dp), horizontalAlignment = Alignment.CenterHorizontally) {&#10;            val baseValue = MaterialTheme.typography.titleMedium&#10;            val isTime = value.contains(&quot;:&quot;)&#10;            val baseFactor = if (isTime) 0.92f else 0.98f&#10;            val valueSize = (baseValue.fontSize.value * baseFactor).sp&#10;            val valueStyle = baseValue.copy(&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = valueSize,&#10;                lineHeight = valueSize * 1.1f,&#10;                platformStyle = PlatformTextStyle(includeFontPadding = true),&#10;                fontFeatureSettings = &quot;tnum&quot;&#10;            )&#10;            Box(modifier = Modifier.fillMaxWidth().height(34.dp), contentAlignment = Alignment.Center) {&#10;                AutoResizeSingleLineText(&#10;                    text = value,&#10;                    baseStyle = valueStyle,&#10;                    minFontSizeSp = (baseValue.fontSize.value * 0.75f),&#10;                    color = color,&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            val baseLabel = MaterialTheme.typography.labelMedium&#10;            val labelStyle = baseLabel.copy(&#10;                lineHeight = baseLabel.fontSize * 1.2f,&#10;                platformStyle = PlatformTextStyle(includeFontPadding = true)&#10;            )&#10;            Box(modifier = Modifier.fillMaxWidth().height(22.dp), contentAlignment = Alignment.Center) {&#10;                AutoResizeSingleLineText(&#10;                    text = title,&#10;                    baseStyle = labelStyle,&#10;                    minFontSizeSp = (baseLabel.fontSize.value * 0.85f),&#10;                    color = colorResource(id = R.color.color_stat_title_gray),&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun saveCompletedRecord(context: Context, startTime: Long, endTime: Long, targetDays: Float, actualDays: Int) {&#10;    try {&#10;        val sharedPref = context.getSharedPreferences(Constants.USER_SETTINGS_PREFS, Context.MODE_PRIVATE)&#10;        val recordId = System.currentTimeMillis().toString()&#10;        val isCompleted = actualDays &gt;= targetDays&#10;        val status = if (isCompleted) &quot;완료&quot; else &quot;중지&quot;&#10;        val record = org.json.JSONObject().apply {&#10;            put(&quot;id&quot;, recordId); put(&quot;startTime&quot;, startTime); put(&quot;endTime&quot;, endTime); put(&quot;targetDays&quot;, targetDays.toInt()); put(&quot;actualDays&quot;, actualDays); put(&quot;isCompleted&quot;, isCompleted); put(&quot;status&quot;, status); put(&quot;createdAt&quot;, System.currentTimeMillis())&#10;        }&#10;        val recordsJson = sharedPref.getString(Constants.PREF_SOBRIETY_RECORDS, &quot;[]&quot;) ?: &quot;[]&quot;&#10;        val list = try { org.json.JSONArray(recordsJson) } catch (_: Exception) { org.json.JSONArray() }&#10;        list.put(record)&#10;        sharedPref.edit { putString(Constants.PREF_SOBRIETY_RECORDS, list.toString()) }&#10;    } catch (_: Exception) { }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sweetapps.nosmoketimer.feature.run&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.content.Intent&#13;&#10;import android.os.Bundle&#13;&#10;import android.widget.Toast&#13;&#10;import androidx.activity.compose.setContent&#13;&#10;import androidx.compose.animation.core.animateFloatAsState&#13;&#10;import androidx.compose.animation.core.tween&#13;&#10;import androidx.compose.foundation.clickable&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.foundation.shape.CircleShape&#13;&#10;import androidx.compose.foundation.background&#13;&#10;import androidx.compose.ui.draw.clip&#13;&#10;import androidx.compose.material.icons.Icons&#13;&#10;import androidx.compose.material.icons.filled.Close&#13;&#10;import androidx.compose.material3.*&#13;&#10;import androidx.compose.runtime.*&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.compose.ui.platform.LocalContext&#13;&#10;import androidx.compose.ui.res.colorResource&#13;&#10;import androidx.compose.ui.res.stringResource&#13;&#10;import androidx.compose.ui.text.PlatformTextStyle&#13;&#10;import androidx.compose.ui.text.TextStyle&#13;&#10;import androidx.compose.ui.text.style.TextOverflow&#13;&#10;import androidx.compose.ui.text.style.TextAlign&#13;&#10;import androidx.compose.ui.text.font.FontWeight&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.compose.ui.unit.sp&#13;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#13;&#10;import androidx.core.content.edit&#13;&#10;import java.util.Locale&#13;&#10;import com.sweetapps.nosmoketimer.core.ui.BaseActivity&#13;&#10;import com.sweetapps.nosmoketimer.core.ui.StandardScreenWithBottomButton&#13;&#10;import com.sweetapps.nosmoketimer.core.util.Constants&#13;&#10;import com.sweetapps.nosmoketimer.feature.level.LevelDefinitions&#13;&#10;import com.sweetapps.nosmoketimer.core.util.FormatUtils&#13;&#10;import kotlinx.coroutines.delay&#13;&#10;import com.sweetapps.nosmoketimer.feature.start.StartActivity&#13;&#10;import com.sweetapps.nosmoketimer.feature.detail.DetailActivity&#13;&#10;import com.sweetapps.nosmoketimer.core.ui.AppElevation&#13;&#10;import androidx.compose.foundation.BorderStroke&#13;&#10;import com.sweetapps.nosmoketimer.R&#13;&#10;&#13;&#10;class RunActivity : BaseActivity() {&#13;&#10;&#13;&#10;    override fun getScreenTitle(): String = getString(R.string.run_title)&#13;&#10;&#13;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#13;&#10;        super.onCreate(savedInstanceState)&#13;&#10;        setContent {&#13;&#10;            BaseScreen(applyBottomInsets = false) {&#13;&#10;                RunScreen()&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;private fun RunScreen() {&#13;&#10;    val context = LocalContext.current&#13;&#10;&#13;&#10;    val sp = remember { context.getSharedPreferences(Constants.USER_SETTINGS_PREFS, Context.MODE_PRIVATE) }&#13;&#10;    val startTime = remember { sp.getLong(Constants.PREF_START_TIME, 0L) }&#13;&#10;    val targetDays = remember { sp.getFloat(Constants.PREF_TARGET_DAYS, 30f) }&#13;&#10;    val timerCompleted = remember { sp.getBoolean(Constants.PREF_TIMER_COMPLETED, false) }&#13;&#10;&#13;&#10;    LaunchedEffect(startTime, timerCompleted) {&#13;&#10;        if (timerCompleted || startTime == 0L) {&#13;&#10;            context.startActivity(Intent(context, StartActivity::class.java).apply {&#13;&#10;                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)&#13;&#10;            })&#13;&#10;            (context as? RunActivity)?.finish()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    var now by remember { mutableLongStateOf(System.currentTimeMillis()) }&#13;&#10;    LaunchedEffect(Unit) {&#13;&#10;        while (true) {&#13;&#10;            delay(1000)&#13;&#10;            now = System.currentTimeMillis()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    val elapsedMillis by remember(now, startTime) {&#13;&#10;        derivedStateOf { if (startTime &gt; 0) now - startTime else 0L }&#13;&#10;    }&#13;&#10;    val elapsedDaysFloat = remember(elapsedMillis) { elapsedMillis / Constants.DAY_IN_MILLIS.toFloat() }&#13;&#10;    val elapsedDays = remember(elapsedDaysFloat) { elapsedDaysFloat.toInt() }&#13;&#10;&#13;&#10;    val levelDays = remember(elapsedMillis) { Constants.calculateLevelDays(elapsedMillis) }&#13;&#10;    val levelInfo = remember(levelDays) { LevelDefinitions.getLevelInfo(levelDays) }&#13;&#10;    val levelName = levelInfo.name&#13;&#10;&#13;&#10;    val elapsedHours = ((elapsedMillis % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000)).toInt()&#13;&#10;    val elapsedMinutes = ((elapsedMillis % (60 * 60 * 1000)) / (60 * 1000)).toInt()&#13;&#10;    val elapsedSeconds = ((elapsedMillis % (60 * 1000)) / 1000).toInt()&#13;&#10;    val progressTimeText = String.format(Locale.getDefault(), &quot;%02d:%02d:%02d&quot;, elapsedHours, elapsedMinutes, elapsedSeconds)&#13;&#10;    val progressTimeTextHM = String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, elapsedHours, elapsedMinutes)&#13;&#10;&#13;&#10;    val (selectedCost, selectedFrequency, selectedDuration) = Constants.getUserSettings(context)&#13;&#10;    val costVal = when (selectedCost) { &quot;저&quot; -&gt; 3000; &quot;중&quot; -&gt; 6000; &quot;고&quot; -&gt; 12000; else -&gt; 6000 }&#13;&#10;    val freqVal = when (selectedFrequency) { &quot;주 1회 이하&quot; -&gt; 1.0; &quot;주 2~3회&quot; -&gt; 2.5; &quot;주 4회 이상&quot; -&gt; 5.0; else -&gt; 2.5 }&#13;&#10;    val drinkHoursVal = when (selectedDuration) { &quot;짧음&quot; -&gt; 2; &quot;보통&quot; -&gt; 4; &quot;김&quot; -&gt; 6; else -&gt; 4 }&#13;&#10;    val weeks = elapsedDaysFloat / 7.0&#13;&#10;    val savedMoney = remember(weeks, freqVal, costVal) { weeks * freqVal * costVal }&#13;&#10;    val savedHours = remember(weeks, freqVal, drinkHoursVal) { weeks * freqVal * (drinkHoursVal + Constants.DEFAULT_HANGOVER_HOURS) }&#13;&#10;    val lifeGainDays = remember(elapsedDaysFloat) { elapsedDaysFloat / 30.0 }&#13;&#10;&#13;&#10;    val totalTargetMillis = (targetDays * Constants.DAY_IN_MILLIS).toLong()&#13;&#10;    val progress = remember(elapsedMillis, totalTargetMillis) {&#13;&#10;        if (totalTargetMillis &gt; 0) (elapsedMillis.toFloat() / totalTargetMillis).coerceIn(0f, 1f) else 0f&#13;&#10;    }&#13;&#10;&#13;&#10;    val indicatorKey = remember(startTime) { Constants.keyCurrentIndicator(startTime) }&#13;&#10;    var currentIndicator by remember { mutableIntStateOf(sp.getInt(indicatorKey, 0)) }&#13;&#10;&#13;&#10;    fun toggleIndicator() { val next = (currentIndicator + 1) % 5; currentIndicator = next; sp.edit { putInt(indicatorKey, next) } }&#13;&#10;&#13;&#10;    var hasCompleted by remember { mutableStateOf(false) }&#13;&#10;    LaunchedEffect(progress) {&#13;&#10;        if (!hasCompleted &amp;&amp; progress &gt;= 1f &amp;&amp; startTime &gt; 0) {&#13;&#10;            try {&#13;&#10;                saveCompletedRecord(&#13;&#10;                    context = context,&#13;&#10;                    startTime = startTime,&#13;&#10;                    endTime = System.currentTimeMillis(),&#13;&#10;                    targetDays = targetDays,&#13;&#10;                    actualDays = (elapsedMillis / Constants.DAY_IN_MILLIS).toInt()&#13;&#10;                )&#13;&#10;                sp.edit { remove(Constants.PREF_START_TIME); putBoolean(Constants.PREF_TIMER_COMPLETED, true) }&#13;&#10;                hasCompleted = true&#13;&#10;                Toast.makeText(context, context.getString(R.string.toast_goal_completed), Toast.LENGTH_SHORT).show()&#13;&#10;                DetailActivity.start(&#13;&#10;                    context = context,&#13;&#10;                    startTime = startTime,&#13;&#10;                    endTime = System.currentTimeMillis(),&#13;&#10;                    targetDays = targetDays,&#13;&#10;                    actualDays = (elapsedMillis / Constants.DAY_IN_MILLIS).toInt(),&#13;&#10;                    isCompleted = true&#13;&#10;                )&#13;&#10;                (context as? RunActivity)?.finish()&#13;&#10;            } catch (_: Exception) { }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    StandardScreenWithBottomButton(&#13;&#10;        topContent = {&#13;&#10;            Card(&#13;&#10;                modifier = Modifier.fillMaxWidth(),&#13;&#10;                shape = RoundedCornerShape(16.dp),&#13;&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),&#13;&#10;                elevation = CardDefaults.cardElevation(defaultElevation = AppElevation.CARD),&#13;&#10;                border = BorderStroke(1.dp, colorResource(id = R.color.color_border_light))&#13;&#10;            ) {&#13;&#10;                Column(modifier = Modifier.fillMaxWidth().padding(20.dp)) {&#13;&#10;                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#13;&#10;                        RunStatChip(title = stringResource(id = R.string.stat_goal_days), value = &quot;${targetDays.toInt()}일&quot;, color = colorResource(id = R.color.color_stat_goal), modifier = Modifier.weight(1f))&#13;&#10;                        RunStatChip(title = stringResource(id = R.string.stat_level), value = levelName.take(6), color = levelInfo.color, modifier = Modifier.weight(1f))&#13;&#10;                        RunStatChip(title = stringResource(id = R.string.stat_time), value = progressTimeTextHM, color = colorResource(id = R.color.color_stat_time), modifier = Modifier.weight(1f))&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            Spacer(modifier = Modifier.height(8.dp))&#13;&#10;&#13;&#10;            Card(&#13;&#10;                modifier = Modifier.fillMaxWidth().height(168.dp).clickable { toggleIndicator() },&#13;&#10;                shape = RoundedCornerShape(16.dp),&#13;&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),&#13;&#10;                elevation = CardDefaults.cardElevation(defaultElevation = AppElevation.CARD),&#13;&#10;                border = BorderStroke(1.dp, colorResource(id = R.color.color_border_light))&#13;&#10;            ) {&#13;&#10;                Box(modifier = Modifier.fillMaxSize().padding(16.dp), contentAlignment = Alignment.Center) {&#13;&#10;                    val labelBoxH = 36.dp; val valueBoxH = 66.dp; val hintBoxH = 20.dp; val gapSmall = 6.dp; val gapMedium = 8.dp&#13;&#10;                    val (label, valueText, valueColor) = when (currentIndicator) {&#13;&#10;                        0 -&gt; Triple(stringResource(id = R.string.indicator_title_days), String.format(Locale.getDefault(), &quot;%.1f&quot;, elapsedDaysFloat), colorResource(id = R.color.color_indicator_days))&#13;&#10;                        1 -&gt; Triple(stringResource(id = R.string.indicator_title_time), progressTimeText, colorResource(id = R.color.color_indicator_time))&#13;&#10;                        2 -&gt; Triple(stringResource(id = R.string.indicator_title_saved_money), String.format(Locale.getDefault(), &quot;%,.0f원&quot;, savedMoney).replace(&quot; &quot;, &quot;&quot;), colorResource(id = R.color.color_indicator_money))&#13;&#10;                        3 -&gt; Triple(stringResource(id = R.string.indicator_title_saved_hours), String.format(Locale.getDefault(), &quot;%.1f&quot;, savedHours), colorResource(id = R.color.color_indicator_hours))&#13;&#10;                        else -&gt; Triple(stringResource(id = R.string.indicator_title_life_gain), FormatUtils.daysToDayHourString(lifeGainDays, 2), colorResource(id = R.color.color_indicator_life))&#13;&#10;                    }&#13;&#10;                    Column(horizontalAlignment = Alignment.CenterHorizontally) {&#13;&#10;                        Box(modifier = Modifier.fillMaxWidth().height(labelBoxH), contentAlignment = Alignment.Center) {&#13;&#10;                            val base = MaterialTheme.typography.titleMedium&#13;&#10;                            Text(&#13;&#10;                                text = label,&#13;&#10;                                style = base.copy(&#13;&#10;                                    color = colorResource(id = R.color.color_indicator_label_gray),&#13;&#10;                                    lineHeight = base.fontSize * 1.2f,&#13;&#10;                                    platformStyle = PlatformTextStyle(includeFontPadding = true)&#13;&#10;                                ),&#13;&#10;                                textAlign = TextAlign.Center,&#13;&#10;                                maxLines = 1,&#13;&#10;                                overflow = TextOverflow.Ellipsis&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                        Spacer(modifier = Modifier.height(gapSmall))&#13;&#10;                        Box(modifier = Modifier.fillMaxWidth().height(valueBoxH), contentAlignment = Alignment.Center) {&#13;&#10;                            val baseStyle = MaterialTheme.typography.headlineMedium&#13;&#10;                            val bigSize = (baseStyle.fontSize.value * 1.5f).sp&#13;&#10;                            val bigStyle = baseStyle.copy(&#13;&#10;                                fontWeight = FontWeight.Bold,&#13;&#10;                                color = valueColor,&#13;&#10;                                fontSize = bigSize,&#13;&#10;                                lineHeight = bigSize * 1.1f,&#13;&#10;                                platformStyle = PlatformTextStyle(includeFontPadding = true),&#13;&#10;                                fontFeatureSettings = &quot;tnum&quot;&#13;&#10;                            )&#13;&#10;                            val unitStyle = baseStyle.copy(&#13;&#10;                                color = valueColor,&#13;&#10;                                fontWeight = FontWeight.SemiBold,&#13;&#10;                                fontSize = baseStyle.fontSize,&#13;&#10;                                lineHeight = baseStyle.fontSize * 1.1f,&#13;&#10;                                platformStyle = PlatformTextStyle(includeFontPadding = true)&#13;&#10;                            )&#13;&#10;                            val isMoney = currentIndicator == 2&#13;&#10;                            val isLifeGain = currentIndicator == 4&#13;&#10;                            if (isMoney) {&#13;&#10;                                val numeric = valueText.replace(&quot;원&quot;, &quot;&quot;)&#13;&#10;                                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#13;&#10;                                    Text(text = numeric, style = bigStyle, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip, modifier = Modifier.alignByBaseline())&#13;&#10;                                    Spacer(modifier = Modifier.width(2.dp))&#13;&#10;                                    Text(text = &quot;원&quot;, style = unitStyle, modifier = Modifier.alignByBaseline())&#13;&#10;                                }&#13;&#10;                            } else if (isLifeGain) {&#13;&#10;                                val twoPart = Regex(&quot;&quot;&quot;(\d+)\s*일\s*([0-9]+(?:\.[0-9]+)?)\s*시간&quot;&quot;&quot;)&#13;&#10;                                val onePart = Regex(&quot;&quot;&quot;([0-9]+(?:\.[0-9]+)?)\s*시간&quot;&quot;&quot;)&#13;&#10;                                val m1 = twoPart.find(valueText)&#13;&#10;                                val m2 = if (m1 == null) onePart.find(valueText) else null&#13;&#10;                                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#13;&#10;                                    if (m1 != null) {&#13;&#10;                                        val dStr = m1.groupValues[1]&#13;&#10;                                        val hStr = m1.groupValues[2]&#13;&#10;                                        Text(text = dStr, style = bigStyle, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip, modifier = Modifier.alignByBaseline())&#13;&#10;                                        Spacer(modifier = Modifier.width(2.dp))&#13;&#10;                                        Text(text = &quot;일&quot;, style = unitStyle, modifier = Modifier.alignByBaseline())&#13;&#10;                                        Spacer(modifier = Modifier.width(6.dp))&#13;&#10;                                        Text(text = hStr, style = bigStyle, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip, modifier = Modifier.alignByBaseline())&#13;&#10;                                        Spacer(modifier = Modifier.width(2.dp))&#13;&#10;                                        Text(text = &quot;시간&quot;, style = unitStyle, modifier = Modifier.alignByBaseline())&#13;&#10;                                    } else if (m2 != null) {&#13;&#10;                                        val hStr = m2.groupValues[1]&#13;&#10;                                        Text(text = hStr, style = bigStyle, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip, modifier = Modifier.alignByBaseline())&#13;&#10;                                        Spacer(modifier = Modifier.width(2.dp))&#13;&#10;                                        Text(text = &quot;시간&quot;, style = unitStyle, modifier = Modifier.alignByBaseline())&#13;&#10;                                    } else {&#13;&#10;                                        Text(text = valueText, style = bigStyle, textAlign = TextAlign.Center, maxLines = 1, softWrap = false, overflow = TextOverflow.Clip)&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                            } else {&#13;&#10;                                Text(&#13;&#10;                                    text = valueText,&#13;&#10;                                    style = bigStyle,&#13;&#10;                                    textAlign = TextAlign.Center,&#13;&#10;                                    maxLines = 1,&#13;&#10;                                    softWrap = false,&#13;&#10;                                    overflow = TextOverflow.Clip&#13;&#10;                                )&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                        Spacer(modifier = Modifier.height(gapMedium))&#13;&#10;                        Box(modifier = Modifier.fillMaxWidth().height(hintBoxH), contentAlignment = Alignment.Center) {&#13;&#10;                            val base = MaterialTheme.typography.labelMedium&#13;&#10;                            Text(&#13;&#10;                                text = stringResource(id = R.string.tap_to_switch_indicator),&#13;&#10;                                style = base.copy(&#13;&#10;                                    color = colorResource(id = R.color.color_hint_gray),&#13;&#10;                                    lineHeight = base.fontSize * 1.2f,&#13;&#10;                                    platformStyle = PlatformTextStyle(includeFontPadding = true)&#13;&#10;                                ),&#13;&#10;                                textAlign = TextAlign.Center,&#13;&#10;                                maxLines = 1,&#13;&#10;                                overflow = TextOverflow.Ellipsis&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            Spacer(modifier = Modifier.height(8.dp))&#13;&#10;&#13;&#10;            Card(&#13;&#10;                modifier = Modifier.fillMaxWidth(),&#13;&#10;                shape = RoundedCornerShape(16.dp),&#13;&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),&#13;&#10;                elevation = CardDefaults.cardElevation(defaultElevation = AppElevation.CARD),&#13;&#10;                border = BorderStroke(1.dp, colorResource(id = R.color.color_border_light))&#13;&#10;            ) {&#13;&#10;                Column(modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) { ModernProgressIndicatorSimple(progress = progress) }&#13;&#10;            }&#13;&#10;        },&#13;&#10;        bottomButton = {&#13;&#10;            ModernStopButtonSimple(onStop = {&#13;&#10;                val intent = Intent(context, QuitActivity::class.java).apply {&#13;&#10;                    putExtra(&quot;elapsed_days&quot;, elapsedDays)&#13;&#10;                    putExtra(&quot;elapsed_hours&quot;, elapsedHours)&#13;&#10;                    putExtra(&quot;elapsed_minutes&quot;, elapsedMinutes)&#13;&#10;                    putExtra(&quot;saved_money&quot;, savedMoney)&#13;&#10;                    putExtra(&quot;saved_hours&quot;, savedHours)&#13;&#10;                    putExtra(&quot;life_gain_days&quot;, lifeGainDays)&#13;&#10;                    putExtra(&quot;level_name&quot;, levelName)&#13;&#10;                    putExtra(&quot;level_color&quot;, levelInfo.color.value.toLong())&#13;&#10;                    putExtra(&quot;quit_timestamp&quot;, System.currentTimeMillis())&#13;&#10;                }&#13;&#10;                context.startActivity(intent)&#13;&#10;            })&#13;&#10;        }&#13;&#10;    )&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;private fun ModernProgressIndicatorSimple(progress: Float) {&#13;&#10;    var blink by remember { mutableStateOf(true) }&#13;&#10;    LaunchedEffect(Unit) { while (true) { delay(1000); blink = !blink } }&#13;&#10;    val alpha by animateFloatAsState(targetValue = if (blink) 1f else 0.3f, animationSpec = tween(durationMillis = 500, easing = androidx.compose.animation.core.FastOutSlowInEasing), label = &quot;blink&quot;)&#13;&#10;&#13;&#10;    Column(horizontalAlignment = Alignment.CenterHorizontally) {&#13;&#10;        Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.Center) {&#13;&#10;            Text(text = (progress * 100).toInt().coerceIn(0, 100).toString() + &quot;%&quot;, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold, color = colorResource(id = R.color.color_progress_primary)))&#13;&#10;            Spacer(modifier = Modifier.width(8.dp))&#13;&#10;            Box(modifier = Modifier.size(6.dp).clip(CircleShape).background(colorResource(id = R.color.color_progress_primary).copy(alpha = alpha)))&#13;&#10;        }&#13;&#10;        Spacer(modifier = Modifier.height(8.dp))&#13;&#10;        LinearProgressIndicator(progress = { progress }, color = colorResource(id = R.color.color_progress_primary), trackColor = colorResource(id = R.color.color_progress_track), modifier = Modifier.fillMaxWidth().height(8.dp))&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@OptIn(ExperimentalMaterial3Api::class)&#13;&#10;@Composable&#13;&#10;private fun ModernStopButtonSimple(onStop: () -&gt; Unit, modifier: Modifier = Modifier) {&#13;&#10;    Card(&#13;&#10;        onClick = onStop,&#13;&#10;        modifier = modifier.size(96.dp),&#13;&#10;        shape = CircleShape,&#13;&#10;        colors = CardDefaults.cardColors(containerColor = colorResource(id = R.color.color_stop_button)),&#13;&#10;        elevation = CardDefaults.cardElevation(defaultElevation = AppElevation.CARD_HIGH)&#13;&#10;    ) {&#13;&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#13;&#10;            Icon(&#13;&#10;                imageVector = Icons.Default.Close,&#13;&#10;                contentDescription = stringResource(id = R.string.cd_stop),&#13;&#10;                tint = Color.White,&#13;&#10;                modifier = Modifier.size(48.dp)&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;private fun AutoResizeSingleLineText(&#13;&#10;    text: String,&#13;&#10;    baseStyle: TextStyle,&#13;&#10;    modifier: Modifier = Modifier,&#13;&#10;    minFontSizeSp: Float = 10f,&#13;&#10;    step: Float = 0.95f,&#13;&#10;    color: Color? = null,&#13;&#10;    textAlign: TextAlign? = null,&#13;&#10;) {&#13;&#10;    var style by remember(text) { mutableStateOf(baseStyle) }&#13;&#10;    var tried by remember(text) { mutableStateOf(0) }&#13;&#10;    Text(&#13;&#10;        text = text,&#13;&#10;        style = style,&#13;&#10;        color = color ?: style.color,&#13;&#10;        textAlign = textAlign,&#13;&#10;        maxLines = 1,&#13;&#10;        softWrap = false,&#13;&#10;        overflow = TextOverflow.Clip,&#13;&#10;        modifier = modifier,&#13;&#10;        onTextLayout = { result -&gt;&#13;&#10;            if (result.hasVisualOverflow &amp;&amp; tried &lt; 20) {&#13;&#10;                val current = style.fontSize.value&#13;&#10;                val next = (current * step).coerceAtLeast(minFontSizeSp)&#13;&#10;                if (next &lt; current - 0.1f) {&#13;&#10;                    style = style.copy(fontSize = next.sp, lineHeight = (next.sp * 1.1f))&#13;&#10;                    tried++&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    )&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;private fun RunStatChip(title: String, value: String, color: Color, modifier: Modifier = Modifier) {&#13;&#10;    Surface(modifier = modifier.height(84.dp), shape = RoundedCornerShape(12.dp), color = color.copy(alpha = 0.1f)) {&#13;&#10;        Column(modifier = Modifier.fillMaxWidth().padding(12.dp), horizontalAlignment = Alignment.CenterHorizontally) {&#13;&#10;            val baseValue = MaterialTheme.typography.titleMedium&#13;&#10;            val isTime = value.contains(&quot;:&quot;)&#13;&#10;            val baseFactor = if (isTime) 0.92f else 0.98f&#13;&#10;            val valueSize = (baseValue.fontSize.value * baseFactor).sp&#13;&#10;            val valueStyle = baseValue.copy(&#13;&#10;                fontWeight = FontWeight.Bold,&#13;&#10;                fontSize = valueSize,&#13;&#10;                lineHeight = valueSize * 1.1f,&#13;&#10;                platformStyle = PlatformTextStyle(includeFontPadding = true),&#13;&#10;                fontFeatureSettings = &quot;tnum&quot;&#13;&#10;            )&#13;&#10;            Box(modifier = Modifier.fillMaxWidth().height(34.dp), contentAlignment = Alignment.Center) {&#13;&#10;                AutoResizeSingleLineText(&#13;&#10;                    text = value,&#13;&#10;                    baseStyle = valueStyle,&#13;&#10;                    minFontSizeSp = (baseValue.fontSize.value * 0.75f),&#13;&#10;                    color = color,&#13;&#10;                    textAlign = TextAlign.Center,&#13;&#10;                    modifier = Modifier.fillMaxWidth()&#13;&#10;                )&#13;&#10;            }&#13;&#10;            Spacer(modifier = Modifier.height(4.dp))&#13;&#10;            val baseLabel = MaterialTheme.typography.labelMedium&#13;&#10;            val labelStyle = baseLabel.copy(&#13;&#10;                lineHeight = baseLabel.fontSize * 1.2f,&#13;&#10;                platformStyle = PlatformTextStyle(includeFontPadding = true)&#13;&#10;            )&#13;&#10;            Box(modifier = Modifier.fillMaxWidth().height(22.dp), contentAlignment = Alignment.Center) {&#13;&#10;                AutoResizeSingleLineText(&#13;&#10;                    text = title,&#13;&#10;                    baseStyle = labelStyle,&#13;&#10;                    minFontSizeSp = (baseLabel.fontSize.value * 0.85f),&#13;&#10;                    color = colorResource(id = R.color.color_stat_title_gray),&#13;&#10;                    textAlign = TextAlign.Center,&#13;&#10;                    modifier = Modifier.fillMaxWidth()&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;private fun saveCompletedRecord(context: Context, startTime: Long, endTime: Long, targetDays: Float, actualDays: Int) {&#13;&#10;    try {&#13;&#10;        val sharedPref = context.getSharedPreferences(Constants.USER_SETTINGS_PREFS, Context.MODE_PRIVATE)&#13;&#10;        val recordId = System.currentTimeMillis().toString()&#13;&#10;        val isCompleted = actualDays &gt;= targetDays&#13;&#10;        val status = if (isCompleted) &quot;완료&quot; else &quot;중지&quot;&#13;&#10;        val record = org.json.JSONObject().apply {&#13;&#10;            put(&quot;id&quot;, recordId); put(&quot;startTime&quot;, startTime); put(&quot;endTime&quot;, endTime); put(&quot;targetDays&quot;, targetDays.toInt()); put(&quot;actualDays&quot;, actualDays); put(&quot;isCompleted&quot;, isCompleted); put(&quot;status&quot;, status); put(&quot;createdAt&quot;, System.currentTimeMillis())&#13;&#10;        }&#13;&#10;        val recordsJson = sharedPref.getString(Constants.PREF_SOBRIETY_RECORDS, &quot;[]&quot;) ?: &quot;[]&quot;&#13;&#10;        val list = try { org.json.JSONArray(recordsJson) } catch (_: Exception) { org.json.JSONArray() }&#13;&#10;        list.put(record)&#13;&#10;        sharedPref.edit { putString(Constants.PREF_SOBRIETY_RECORDS, list.toString()) }&#13;&#10;    } catch (_: Exception) { }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>